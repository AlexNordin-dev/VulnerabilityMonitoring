using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using VulnerabilityMonitoring.Models.AccountViewModels;
using VulnerabilityMonitoring.Services.Account;

namespace VulnerabilityMonitoring.Controllers;

[Authorize]
public class AccountController : Controller
{
    private readonly UserManager<IdentityUser> _userManager;
    private readonly SignInManager<IdentityUser> _signInManager;
    //private readonly IEmailSender<IdentityUser> _emailSender;
    //private readonly IdentityContext _identityDB;
    private readonly ILogger<AccountController> _logger;
    private readonly IProfileService _profileService;
    private readonly IAccountService _accountService;

    public AccountController(UserManager<IdentityUser> userManager, SignInManager<IdentityUser> signInManager, ILogger<AccountController> logger, IProfileService profileService, IAccountService accountService)
    {
        _userManager = userManager;
        _signInManager = signInManager;
        _logger = logger;
        _profileService = profileService;
        _accountService = accountService;
    }



    public async Task<IActionResult> Profile()
    {
        var user = await _userManager.GetUserAsync(User);
        var profile = await _accountService.GetByIdAsync(user.Id);
        var model = new SettingProfileViewModel
        {
            Profile = new ProfileViewModel
            {
                Id = profile.Id,
                FirstName = profile.FirstName,
                LastName = profile.LastName,
                Email = profile.Email,
                ImageName = profile.ImageName
            },
            Setting = new SettingViewModel
            {
                EnableHighSeverity = profile.EnableHighSeverity,
                EnableModerateSeverity = profile.EnableModerateSeverity,
                EnableCriticalSeverity = profile.EnableCriticalSeverity,
                EnableAllSeverity = profile.EnableAllSeverity,
                DisableNotifications = profile.DisableNotifications
            }

        };


        return View(model);
    }


    [Route("Account/UpdateProfile")]
    [HttpPost]
    public async Task<IActionResult> UpdateProfile([FromBody] ProfileViewModel models)
    {
        if (!ModelState.IsValid)
            return View(models);

        var user = await _userManager.GetUserAsync(User);
        var profile = await _accountService.GetByIdAsync(user.Id);
        var model = new ProfileViewModel
        {
            Id = profile.Id,
        };
        var result = await _accountService.UpdateProfileAsync(models);
        if (result == false)
            return StatusCode(500);



        return Ok();
    }

    [Route("Account/UpdateSeverity")]
    [HttpPost]
    public async Task<IActionResult> UpdateSeverity([FromBody] SettingViewModel models)
    {
        try
        {
            if (!ModelState.IsValid)
                return View(models);

            var user = await _userManager.GetUserAsync(User);
            var profile = await _accountService.GetByIdAsync(user.Id);
            var result = await _accountService.UpdateSeverityAsync(models, profile.Id);
            if (result == false)
                return StatusCode(500);


            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex.Message);
            return StatusCode(500);
        }
    }

    [HttpGet]
    [AllowAnonymous]
    public async Task<IActionResult> Login(string returnUrl = null!)
    {
        // Clear the existing external cookie to ensure a clean login process
        await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme);

        var form = new LoginViewModel
        {
            ReturnUrl = returnUrl ?? Url.Content("~/")
        };

        return View(form);
    }

    [HttpPost]
    [AllowAnonymous]
    public async Task<IActionResult> Login(LoginViewModel model)
    {

        if (ModelState.IsValid)
        {

            var result = await _signInManager.PasswordSignInAsync(model.Email, model.Password, model.RememberMe, lockoutOnFailure: false);
            if (result.Succeeded)
            {
                _logger.LogInformation("User logged in.");
                return LocalRedirect(model.ReturnUrl);
            }
            if (result.IsLockedOut)
            {
                _logger.LogWarning("User account locked out.");
                return RedirectToAction(nameof(Lockout));
            }
            else
            {
                ModelState.AddModelError(string.Empty, "Invalid login attempt.");
                return View(model);
            }
        }

        return View(model);
    }




    [HttpGet]
    [AllowAnonymous]
    public IActionResult Lockout()
    {
        return View();
    }

    [HttpGet]
    [AllowAnonymous]
    public async Task<IActionResult> Register(string ReturnUrl = null!)
    {
        if (!await _userManager.Users.AnyAsync())
            return RedirectToAction("Installation", "Admin");

        var form = new RegisterViewModel
        {
            ReturnUrl = ReturnUrl ?? Url.Content("~/")
        };

        return View(form);
    }

    [HttpPost]
    [AllowAnonymous]
    public async Task<IActionResult> Register(RegisterViewModel model)
    {

        if (ModelState.IsValid)
        {

            var result = await _accountService.Register(model);
            if (result != null)
            {
                _logger.LogInformation("User created a new account with password.");
                return LocalRedirect(model.ReturnUrl);

            }
            return RedirectToAction("Login");
        }

        ModelState.AddModelError(string.Empty, "Invalid registration attempt.");
        return View(model);
    }

    [HttpGet]
    public async Task<IActionResult> Logout()
    {
        if (_signInManager.IsSignedIn(User))
            await _signInManager.SignOutAsync();
        _logger.LogInformation("User logged out.");
        return LocalRedirect("/");
    }




}

