
# Sökväg till projektets rotmapp
param (
    [String]$projectRoot  
)



# Hämta alla csproj-filer under projektets rotmapp och dess undermappar utan allt som är i "obj och bin"
$csprojFiles = Get-ChildItem -Path $projectRoot -Filter *.csproj -Recurse | Where-Object { $_.PSIsContainer -eq $false -and $_.FullName -notlike "*\obj\*" -and $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\CoreVersion\*" -and $_.Name }

if ($csprojFiles.Count -gt 0) {
    foreach ($csprojFile in $csprojFiles) {
        $projectName = [System.IO.Path]::GetFileNameWithoutExtension($csprojFile.Name)

        try {
            # Uppdatera $projectlocation baserat på skriptets plats i en ny mapp
            $Tprojectlocation = Join-Path $projectRoot "CoreVersionProjecMapp\$projectName\$projectName.csproj"

            # Skapa mappen om den inte redan finns
            $folderPath = Split-Path $Tprojectlocation
            if (-not (Test-Path $folderPath)) {
                New-Item -Path $folderPath -ItemType Directory -Force
            }

            [System.Collections.ArrayList]$packageslist = @();

            Function ListAllPackages ($BaseDirectory) {
                ## Write-Host "Listar ut alla Packages - Detta kan ta en stund ..."
                $PACKAGECONFIGS = Get-ChildItem -Recurse -Force $BaseDirectory -ErrorAction SilentlyContinue | 
                Where-Object { $_.PSIsContainer -eq $false -and $_.FullName -notlike "*\obj\*" -and $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\CoreVersion\*" -and $_.Name -eq "packages.config" }

                ForEach ($PACKAGECONFIG in $PACKAGECONFIGS) {
                   
                    $path = $PACKAGECONFIG.FullName

                    [xml]$packages = Get-Content $path                        

                    foreach ($package in $packages.packages.package) {                               
                        if ($package.developmentDependency -ne "true") {
                            $entry = "<PackageReference Include=`"$($package.id)`" Version=`"$($package.version)`" Framework=`"$($package.targetFramework)`" />"
                            $packageslist.Add($entry)

                            
                        }
                    }
                }
                Write-Host "##[command] Processing $($PACKAGECONFIG.FullName)"
            }

            # Funktion för att skapa *.csproj-fil för ett projekt   
            $Tprojectloca = Join-Path $projectRoot "CoreVersionProjecMapp\$projectName"
            Function CreateProjectFile ($Tprojectloca) {                   
                $uniqueList = $packageslist | Sort-Object  | Get-Unique

                $start = "<Project Sdk=`"Microsoft.NET.Sdk.Web`">

                <PropertyGroup>
                    <TargetFramework>net48</TargetFramework>
                </PropertyGroup>
            
                <ItemGroup>"

                $end = "</ItemGroup>

                        </Project>"

                $total = $start + $uniqueList + $end
                $total | Out-File $Tprojectlocation
            }         

            try {                
                ListAllPackages $csprojFile.DirectoryName > $null          

                CreateProjectFile $Tprojectlocation 
                # dotnet restore $projectName.csproj
                $packageslist.Clear()
            }
            catch {
                Write-Host $_.Exception.Message
            }

        }
        catch {
            Write-Host "Ett fel uppstod vid hantering av $($csprojFile.FullName): $_"
        }
    }

    # Skapa lösningen i mappen CoreVersion
    $solutionPath = Join-Path $projectRoot "CoreVersionProjecMapp\CoreVersion.sln"
    dotnet new sln -n CoreVersion -o $projectRoot\CoreVersionProjecMapp > $null

    # Lägg till projektfiler i lösningen
    foreach ($csprojFile in $csprojFiles) {
        $projectName = [System.IO.Path]::GetFileNameWithoutExtension($csprojFile.Name)
        $projectlocation = Join-Path $projectRoot "CoreVersionProjecMapp\$projectName\$projectName.csproj"
        dotnet sln $solutionPath add $projectlocation > $null
    }

    # Byt till projektmappen
    Set-Location $projectRoot\CoreVersionProjecMapp
    dotnet restore > $null
     
   
 
    Write-Host "$projectRoot"
    Write-Host "$ScriptPath "
    try {
        $result = dotnet list package --vulnerable --include-transitive
        Write-Output $result
    
        $high = $result | Select-String -Pattern 'High' -CaseSensitive
        $low = $result | Select-String -Pattern 'Low' -CaseSensitive
        $moderate = $result | Select-String -Pattern 'Moderate' -CaseSensitive
        $critical = $result | Select-String -Pattern 'Critical' -CaseSensitive
        
        if ($high -or $moderate -or $critical) {
            Write-Host "HighModerateCriticalVulnerabilitiesFound"  
            exit        
        }
        elseif ($low) {
            Write-Host "LowLulnerabilityFound"         
        }
        else {
            Write-Host "NoVulnerabilitiesFound."                    
        }   
    }
    catch {
        Write-Host $_.Exception.Message 
        exit 1    
        
    }
}
else {
    Write-Host $_.Exception.Message   
    exit 1   
}