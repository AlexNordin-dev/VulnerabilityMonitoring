using Microsoft.TeamFoundation.SourceControl.WebApi;
using Microsoft.VisualStudio.Services.Common;
using Microsoft.VisualStudio.Services.WebApi;
using VulnerabilityMonitoring.Models.ViewModels;

namespace VulnerabilityMonitoring.Services.API
{

    public interface IAzureDevOpsService
    {
        Task<VssConnection> CreateVssConnectionAsync();
        Task<List<GitRepository>> GetAllRepositoriesAsync();
        Task<GitRepository> GetRepositoryByIdAsync(string repositoryId);
        Task<ProjectViewModel> SaveRepositoryFilesLocallyAsync(Guid repositoryId);
        Task<bool> DeleteLocalProjectDirectoryAsync(string projectPath);
    }
    public class AzureDevOpsService : IAzureDevOpsService
    {
        private readonly IConfiguration _config;

        public AzureDevOpsService(IConfiguration configuration)
        {
            _config = configuration;
        }
        public Task<VssConnection> CreateVssConnectionAsync()
        {
            var personalAccessToken = _config["AzureDevOps:PersonalAccessToken"];
            var azureDevOpsUrl = _config["AzureDevOps:AzureDevOpsUrl"];
            var organization = _config["AzureDevOps:Organization"];

            var collectionUri = new Uri($"{azureDevOpsUrl}/{organization}/");
            var creds = new VssBasicCredential(string.Empty, personalAccessToken);
            return Task.FromResult(new VssConnection(collectionUri, creds));
        }
        public async Task<List<GitRepository>> GetAllRepositoriesAsync()
        {
            var connection = await CreateVssConnectionAsync();
            var gitHttpClient = connection.GetClient<GitHttpClient>();
            var repositories = await gitHttpClient.GetRepositoriesAsync();
            return repositories;
        }

        public async Task<GitRepository> GetRepositoryByIdAsync(string repositoryId)
        {
            var connection = await CreateVssConnectionAsync();
            var gitHttpClient = connection.GetClient<GitHttpClient>();
            var repository = await gitHttpClient.GetRepositoryAsync(repositoryId);
            return repository;
        }


        public async Task<ProjectViewModel> SaveRepositoryFilesLocallyAsync(Guid repositoryId)
        {
            try
            {
                var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
                var projectFolderPath = Path.Combine(appDataPath, "VulnerabilityMonitoring_AppData");

                var connection = await CreateVssConnectionAsync();
                var gitHttpClient = connection.GetClient<GitHttpClient>();
                var repository = await gitHttpClient.GetRepositoryAsync(repositoryId);
                var items = await gitHttpClient.GetItemsAsync(repositoryId, scopePath: "/", recursionLevel: VersionControlRecursionType.Full);

                var cleanedRepositoryName = GetValidFileName(repository.Name);
                var projectPath = Path.Combine(projectFolderPath, cleanedRepositoryName);
                Directory.CreateDirectory(projectPath);

                bool hasPackagesConfig = items.Any(item => item.Path.EndsWith("packages.config", StringComparison.OrdinalIgnoreCase));
                foreach (var item in items)
                {
                    if (item.GitObjectType == GitObjectType.Blob &&
                        (item.Path.EndsWith(".sln", StringComparison.OrdinalIgnoreCase) || item.Path.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase) || item.Path.EndsWith("packages.config", StringComparison.OrdinalIgnoreCase)))
                    {
                        var file = await gitHttpClient.GetItemContentAsync(repositoryId, item.Path, download: true);

                        // Ändra till att använda hela sökvägen från repositoryt
                        var cleanedItemPath = GetValidFilePath(item.Path);

                        var filePath = Path.Combine(projectPath, cleanedItemPath);
                        Directory.CreateDirectory(Path.GetDirectoryName(filePath));

                        using (var stream = new FileStream(filePath, FileMode.Create, FileAccess.Write))
                        {
                            file.CopyTo(stream);
                        }
                    }
                }
                var projectSlnName = string.Empty;
                var projectSlnPath = string.Empty;
                if (items.Any(i => i.Path.EndsWith(".sln", StringComparison.OrdinalIgnoreCase)))
                {
                    var projectSln = items.First(i => i.Path.EndsWith(".sln", StringComparison.OrdinalIgnoreCase));
                    projectSlnName = GetValidFileName(Path.GetFileName(projectSln.Path));
                    projectSlnPath = Path.Combine(projectPath, GetValidFilePath(projectSln.Path));
                }

                return new ProjectViewModel
                {
                    RepositoryId = repositoryId,
                    ProjectSloName = projectSlnName,
                    RepositoryName = repository.Name,
                    ProjectsPath = projectPath,
                    ProjectsSlnPath = projectSlnPath,
                    SaveDate = DateTime.Now,
                    Branch = repository.DefaultBranch,
                    ProjectReference = repository.ProjectReference.Name,
                    ProjectsFramework = hasPackagesConfig ? "Framework" : "Core",
                };
            }
            catch (Exception)
            {
                return null!;
            }
        }

        // Metod för att rensa bort ogiltiga tecken för filsystemet från en sträng och behålla katalogstrukturen
        private string GetValidFilePath(string filePath)
        {
            var invalidChars = Path.GetInvalidPathChars();
            var pathParts = filePath.Split('/').Select(part => new string(part.Where(c => !invalidChars.Contains(c)).ToArray()));
            return Path.Combine(pathParts.ToArray());
        }


        // Metod för att rensa bort ogiltiga tecken för filsystemet från en sträng
        private string GetValidFileName(string fileName)
        {
            var invalidChars = Path.GetInvalidFileNameChars();
            return new string(fileName.Where(c => !invalidChars.Contains(c)).ToArray());
        }


        public async Task<bool> DeleteLocalProjectDirectoryAsync(string projectPath)
        {
            try
            {
                if (Directory.Exists(projectPath))
                {
                    await Task.Run(() => Directory.Delete(projectPath, true));
                    return true;
                }
                return false;
            }
            catch (Exception)
            {
                return false;
            }
        }

    }
}
